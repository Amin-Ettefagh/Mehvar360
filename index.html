<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Vector Shape Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body,
      #app {
        height: 100%;
      }

      @media (min-width:1024px) {
        body {
          overflow: hidden;
        }
      }

      body {
        background: #030712;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      }

      .glass {
        backdrop-filter: blur(10px);
        background: linear-gradient(180deg, rgba(8, 12, 22, 0.8), rgba(4, 7, 14, 0.85));
        border: 1px solid rgba(255, 255, 255, 0.07);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .header-grad {
        background: linear-gradient(90deg, #070d1b 0%, #0a1429 50%, #070d1b 100%);
      }

      .toast {
        position: fixed;
        right: 20px;
        top: 20px;
        z-index: 60;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 10px 14px;
        border-radius: 12px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #5563ff 0%, #1aa6ff 100%);
        color: #fff;
      }

      .btn-ghost {
        background: rgba(255, 255, 255, 0.05);
        color: #e5e7eb;
        border: 1px solid rgba(255, 255, 255, 0.09);
      }

      .switch {
        position: relative;
        width: 48px;
        height: 28px;
        border-radius: 9999px;
        background: #0a1730;
        border: 1px solid #1b2a49;
        cursor: pointer;
      }

      .switch input {
        display: none;
      }

      .switch span {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: #cbd5e1;
        transition: .2s;
      }

      .switch input:checked+span {
        transform: translateX(20px);
        background: #22c55e;
      }

      input,
      select {
        background: #0a1222 !important;
        color: #e5e7eb !important;
        border: 1px solid #263247 !important;
      }

      input::placeholder {
        color: #8aa0bf;
      }

      #sidebar {
        max-height: calc(100vh - 140px);
        overflow: auto;
      }

      #canvasWrap {
        height: calc(100vh - 220px);
        background: radial-gradient(1200px 600px at 50% -200px, #0a1730 20%, #081225 60%, #060f1f 100%);
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, .65);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 70;
      }

      .modal.show {
        display: flex;
      }

      .badge {
        padding: 4px 8px;
        border-radius: 9999px;
        background: #0a1730;
        border: 1px solid #1d2a46;
        color: #97a6c6;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="app" class="min-h-screen flex flex-col">
      <header class="w-full header-grad border-b border-white/10 py-4 px-6 flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-600 to-sky-500 flex items-center justify-center text-white font-bold shadow-lg">VS</div>
          <div>
            <div class="text-white font-semibold text-lg">Vector Shape Viewer</div>
            <div class="text-slate-400 text-xs">Modern • Dark • Responsive</div>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <span id="userLabel" class="badge">Guest</span>
          <button id="logoutBtn" class="btn btn-ghost" style="display:none">Logout</button>
        </div>
      </header>

      <main class="flex-1 px-6 pb-6 grid grid-cols-1 lg:grid-cols-12 gap-6">
        <!-- Center / Canvas -->
        <section id="centerPanel" class="lg:col-span-9 col-span-1 glass rounded-2xl p-4 flex flex-col">
          <div class="flex items-center justify-between gap-3">
            <div class="text-white font-semibold">Canvas</div>
            <div class="flex items-center gap-4 flex-wrap">
              <div class="flex items-center gap-2">
                <span class="text-slate-300 text-sm">Zoom</span>
                <button id="zoomOut" class="btn btn-ghost">-</button>
                <button id="fitBtn" class="btn btn-ghost">Fit</button>
                <button id="zoomIn" class="btn btn-ghost">+</button>
              </div>
              <div class="flex items-center gap-2 text-slate-200">
                <span class="text-sm">Measurements</span>
                <label class="switch">
                  <input id="toggleMeasurements" type="checkbox" checked>
                  <span></span>
                </label>
              </div>
              <div class="flex items-center gap-2 text-slate-200">
                <span class="text-sm">Magnetive mode</span>
                <label class="switch">
                  <input id="toggleMagnet" type="checkbox">
                  <span></span>
                </label>
              </div>
              <div class="flex items-center gap-2 text-slate-200">
                <!-- متنش را عمومی کردم چون سایز دیگر ثابت ۵ نیست -->
                <span class="text-sm">Segment marks</span>
                <label class="switch">
                  <input id="toggleSegmentSubdiv" type="checkbox">
                  <span></span>
                </label>
              </div>
              <button id="exportPng" class="btn btn-primary rounded-xl">Export PNG</button>
            </div>
          </div>

          <div id="canvasWrap" class="flex-1 mt-3 relative rounded-xl overflow-hidden border border-white/10">
            <canvas id="mainCanvas" class="w-full h-full"></canvas>
            <div id="hoverInfo" class="absolute pointer-events-none p-2 text-xs bg-black/60 text-white rounded-md" style="display:none"></div>
          </div>

          <div class="flex items-center justify-between mt-3 text-slate-400 text-xs">
            <div id="coords">Pan: drag • Zoom: wheel • Click a shape to edit</div>
            <div id="zoomLevel">100%</div>
          </div>
        </section>

        <!-- Sidebar -->
        <aside id="sidebar" class="lg:col-span-3 col-span-1 glass rounded-2xl p-4 flex flex-col gap-6">
          <!-- Data -->
          <div class="flex flex-col gap-3">
            <div class="text-white font-semibold">Data</div>
            <div class="flex gap-2">
              <button id="loadFileBtn" class="btn btn-primary flex-1 rounded-xl">Load JSON / Excel</button>
              <input
                id="fileInput"
                type="file"
                accept=".json,.xlsx,.xls,application/json,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel"
                class="hidden"
              />
            </div>
            <div id="fileName" class="text-slate-400 text-xs">No file loaded</div>
          </div>

          <div class="h-px bg-white/10"></div>

          <!-- Grid -->
          <div class="flex flex-col gap-3">
            <div class="text-white font-semibold items-center flex justify-between">
              <span>Grid</span>
              <div class="flex items-center gap-2 text-slate-200">
                <span class="text-xs">Enable</span>
                <label class="switch">
                  <input id="toggleGrid" type="checkbox">
                  <span></span>
                </label>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 items-center">
              <input
                id="gridSpacing"
                type="number"
                min="1"
                value="5"
                class="rounded-lg px-3 py-2"
                placeholder="Step (cm)"
              />
              <label class="flex items-center justify-between gap-2 text-slate-300 px-2 py-1 rounded-md">
                <span class="text-sm">Grid color</span>
                <input
                  id="gridColor"
                  type="color"
                  value="#1f2937"
                  class="rounded-md w-10 h-10 border border-slate-700"
                />
              </label>
            </div>
          </div>

          <div class="h-px bg-white/10"></div>

          <!-- NEW: Segment line settings (Option C) -->
          <div class="flex flex-col gap-3">
            <div class="text-white font-semibold items-center flex justify-between">
              <span>Segment line</span>
              <span class="badge text-xs">Boundary</span>
            </div>
            <div class="text-slate-300 text-sm">
            </div>
            <div class="grid grid-cols-2 gap-2 items-center">
              <input
                id="segmentStep"
                type="number"
                min="0.1"
                step="0.1"
                value="5"
                class="rounded-lg px-3 py-2"
                placeholder="Segment size (cm)"
              />
              <span class="text-slate-400 text-xs">
              </span>
            </div>
          </div>

          <div class="h-px bg-white/10"></div>

          <!-- Shape Editor -->
          <div class="flex flex-col gap-3">
            <div class="text-white font-semibold">Shape Editor</div>
            <div class="text-slate-300 text-sm">All dimensions are in centimeters</div>
            <div class="grid grid-cols-2 gap-2">
              <select id="shapeType" class="rounded-lg px-3 py-2">
                <option value="square">Square</option>
                <option value="rect">Rectangle</option>
              </select>
              <select id="units" class="rounded-lg px-3 py-2" disabled>
                <option value="cm" selected>centimeters</option>
              </select>
            </div>
            <div id="params" class="flex flex-col gap-2">
              <input id="side" placeholder="Side (cm)" class="rounded-lg px-3 py-2" />
              <input id="width" placeholder="Width (cm)" class="rounded-lg px-3 py-2 hidden" />
              <input id="height" placeholder="Height (cm)" class="rounded-lg px-3 py-2 hidden" />
              <input id="angle" placeholder="Angle ° (clockwise)" class="rounded-lg px-3 py-2" value="0" />

              <div class="grid grid-cols-2 gap-2">
                <label class="flex items-center justify-between gap-2 text-slate-300 px-2 py-1 rounded-md">
                  <span class="text-sm">Stroke</span>
                  <input
                    id="strokeColor"
                    type="color"
                    value="#ffffff"
                    class="rounded-md w-10 h-10 border border-slate-700"
                  />
                </label>
                <label class="flex items-center justify-between gap-2 text-slate-300 px-2 py-1 rounded-md">
                  <span class="text-sm">Fill</span>
                  <input
                    id="fillColor"
                    type="color"
                    value="#000000"
                    class="rounded-md w-10 h-10 border border-slate-700"
                  />
                </label>
              </div>

              <label class="flex items-center gap-2 text-slate-300">
                <input id="noFill" type="checkbox" />
                <span class="text-sm">No Fill</span>
              </label>

              <label class="flex items-center gap-2 text-slate-300">
                <input id="toggleShapeDimsInside" type="checkbox" />
                <span class="text-sm">Show shape size inside</span>
              </label>

              <input
                id="labelText"
                maxlength="3"
                placeholder="Label (max 3 chars)"
                class="rounded-lg px-3 py-2"
              />
            </div>

            <div class="flex gap-2">
              <button id="addShape" class="btn btn-primary rounded-xl flex-1">Add Shape</button>
              <button id="clearShapes" class="btn btn-ghost">Clear</button>
            </div>

            <div class="pt-1">
              <div class="text-slate-300 text-sm">Selected Shape</div>
              <div id="selectedInfo" class="text-white text-sm mt-2">None</div>

              <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="deleteShape" class="btn bg-red-600 text-white rounded-xl">Delete</button>
                <button id="rotateShape" class="btn btn-ghost">Rotate +5°</button>
                <button id="applyEdit" class="btn bg-emerald-600 text-white rounded-xl col-span-2">
                  Apply Edits
                </button>
              </div>
            </div>

            <div class="h-px bg-white/10"></div>

            <div class="pt-1">
              <div class="text-slate-300 text-sm">Import / Export shape</div>
              <div class="flex gap-2 mt-2">
                <button id="importShapeBtn" class="btn btn-ghost flex-1">Import shape JSON</button>
                <button id="exportShapeBtn" class="btn bg-emerald-500 text-white flex-1 rounded-xl">
                  Export shape JSON
                </button>
              </div>
            </div>
        </aside>
      </main>

      <!-- Login Modal -->
      <div id="loginModal" class="modal show">
        <div class="glass rounded-2xl p-6 w-full max-w-sm">
          <div class="text-white text-lg font-semibold mb-4">Sign In</div>
          <div class="flex flex-col gap-3">
            <input id="authUser" placeholder="Username" class="rounded-lg px-3 py-2" />
            <input id="authPass" placeholder="Password" type="password" class="rounded-lg px-3 py-2" />
            <button id="authBtn" class="btn btn-primary w-full rounded-xl">Enter</button>
          </div>
          <div class="text-slate-400 text-xs mt-3">
            Allowed users: Admin/Admin • admin/admin • Rousta/123456789 • Vakili/987654321
          </div>
        </div>
      </div>

      <div id="toasts" class="toast"></div>

      <footer class="py-3 text-center text-slate-500 text-sm">Vector Shape Viewer</footer>
    </div>

    <script>
      const toastWrap = document.getElementById('toasts');

      function toast(msg, kind = 'info') {
        const el = document.createElement('div');
        el.className = 'text-white px-4 py-2 rounded-md mb-2';
        el.style.background = kind === 'err' ? '#b91c1c' : '#0b1222';
        el.textContent = msg;
        toastWrap.appendChild(el);
        setTimeout(() => {
          try {
            toastWrap.removeChild(el);
          } catch (e) {}
        }, 2800);
      }

      const loginModal = document.getElementById('loginModal');
      const authBtn = document.getElementById('authBtn');
      const authUser = document.getElementById('authUser');
      const authPass = document.getElementById('authPass');
      const userLabel = document.getElementById('userLabel');
      const logoutBtn = document.getElementById('logoutBtn');
      let signedIn = false;

      authBtn.addEventListener('click', doLogin);
      authPass.addEventListener('keydown', e => {
        if (e.key === 'Enter') doLogin();
      });

      function doLogin() {
        const u = authUser.value.trim(),
          p = authPass.value.trim();
        if (
          (u === 'Admin' && p === 'Admin') ||
          (u === 'admin' && p === 'admin') ||
          (u === 'Rousta' && p === '123456789') ||
          (u === 'Vakili' && p === '987654321')
        ) {
          signedIn = true;
          userLabel.textContent = u;
          userLabel.classList.remove('badge');
          userLabel.classList.add('text-white');
          loginModal.classList.remove('show');
          logoutBtn.style.display = 'inline-flex';
          toast('Welcome, ' + u);
        } else {
          toast('Invalid credentials', 'err');
        }
      }

      logoutBtn.addEventListener('click', () => {
        signedIn = false;
        userLabel.textContent = 'Guest';
        userLabel.classList.add('badge');
        logoutBtn.style.display = 'none';
        loginModal.classList.add('show');
        clearCanvas();
      });

      const canvas = document.getElementById('mainCanvas'),
        ctx = canvas.getContext('2d');
      let dpr = Math.max(1, window.devicePixelRatio || 1);

      let boundary = [],
        segments = [],
        shapes = [];

      let view = {
        tx: 0,
        ty: 0,
        scale: 1
      };

      let dragging = false,
        lastPos = null,
        draggingShape = null;

      let hoverInfo = document.getElementById('hoverInfo');
      let showMeasurements = true;
      let magnetive = false;
      const MAGNET_THRESHOLD_CM = 10;

      let gridEnabled = false;
      let gridSpacingCm = 5;
      let gridColor = '#1f2937';

      let segmentSubdivEnabled = false;
      let segmentStepCm = 5; // NEW: مقدار تنظیم‌پذیر برای Segment line

      let showShapeDimsInside = false;
      let boundaryArea = 0;
      let boundaryOrientation = 1;

      function updateBoundaryOrientation() {
        if (boundary.length < 3) {
          boundaryArea = 0;
          boundaryOrientation = 1;
          return;
        }
        let area = 0;
        for (let i = 0; i < boundary.length; i++) {
          const j = (i + 1) % boundary.length;
          area += boundary[i][0] * boundary[j][1] - boundary[j][0] * boundary[i][1];
        }
        boundaryArea = area / 2;
        boundaryOrientation = boundaryArea >= 0 ? 1 : -1;
      }

      function resizeCanvas() {
        const rect = document.getElementById('canvasWrap').getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }
      window.addEventListener('resize', resizeCanvas);

      function fitToView() {
        if (boundary.length === 0) return;
        const w = canvas.clientWidth,
          h = canvas.clientHeight;
        const xs = boundary.map(p => p[0]),
          ys = boundary.map(p => p[1]);
        const xmin = Math.min(...xs),
          xmax = Math.max(...xs),
          ymin = Math.min(...ys),
          ymax = Math.max(...ys);
        const bw = Math.max(1, xmax - xmin),
          bh = Math.max(1, ymax - ymin);
        const margin = 40;
        const sx = (w - 2 * margin) / bw,
          sy = (h - 2 * margin) / bh;
        view.scale = Math.min(sx, sy);
        const cx = (xmin + xmax) / 2,
          cy = (ymin + ymax) / 2;
        view.tx = w / 2 - cx * view.scale;
        view.ty = h - (h / 2) - cy * view.scale;
        updateZoomLabel();
      }

      function worldToScreen(x, y) {
        return [x * view.scale + view.tx, canvas.clientHeight - (y * view.scale + view.ty)];
      }

      function screenToWorld(sx, sy) {
        return [(sx - view.tx) / view.scale, (canvas.clientHeight - sy - view.ty) / view.scale];
      }

      function drawGrid(targetCtx, width, height) {
        if (!gridEnabled || gridSpacingCm <= 0) return;
        const topLeft = screenToWorld(0, 0);
        const bottomRight = screenToWorld(width, height);
        const minX = Math.min(topLeft[0], bottomRight[0]);
        const maxX = Math.max(topLeft[0], bottomRight[0]);
        const minY = Math.min(topLeft[1], bottomRight[1]);
        const maxY = Math.max(topLeft[1], bottomRight[1]);
        const step = gridSpacingCm;

        const startX = Math.floor(minX / step) * step;
        const endX = Math.ceil(maxX / step) * step;
        const startY = Math.floor(minY / step) * step;
        const endY = Math.ceil(maxY / step) * step;

        targetCtx.save();
        targetCtx.strokeStyle = gridColor;
        targetCtx.lineWidth = 0.5;
        targetCtx.beginPath();
        for (let x = startX; x <= endX; x += step) {
          const p1 = worldToScreen(x, minY);
          const p2 = worldToScreen(x, maxY);
          targetCtx.moveTo(p1[0], p1[1]);
          targetCtx.lineTo(p2[0], p2[1]);
        }
        for (let y = startY; y <= endY; y += step) {
          const p1 = worldToScreen(minX, y);
          const p2 = worldToScreen(maxX, y);
          targetCtx.moveTo(p1[0], p1[1]);
          targetCtx.lineTo(p2[0], p2[1]);
        }
        targetCtx.stroke();
        targetCtx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        renderToContext(ctx, canvas.clientWidth, canvas.clientHeight, showMeasurements);
      }

      function renderToContext(targetCtx, clientW, clientH, withMeasurements) {
        targetCtx.save();

        // Boundary
        targetCtx.beginPath();
        for (let i = 0; i < boundary.length; i++) {
          const p = worldToScreen(boundary[i][0], boundary[i][1]);
          if (i === 0) targetCtx.moveTo(p[0], p[1]);
          else targetCtx.lineTo(p[0], p[1]);
        }
        if (boundary.length > 2) {
          targetCtx.closePath();
          targetCtx.fillStyle = '#0a152b';
          targetCtx.fill();
        }
        targetCtx.lineWidth = 2;
        targetCtx.strokeStyle = '#4ea3ff';
        if (boundary.length > 1) targetCtx.stroke();

        // Segments
        targetCtx.lineWidth = 1;
        targetCtx.strokeStyle = '#0ea5a6';

        const segStep = Math.max(0.1, segmentStepCm || 0); // استفاده از مقدار تنظیم شده

        for (let i = 0; i < segments.length; i++) {
          const s = segments[i];
          const x1 = s.start_point.x,
            y1 = s.start_point.y,
            x2 = s.end_point.x,
            y2 = s.end_point.y;
          const a = worldToScreen(x1, y1);
          const b = worldToScreen(x2, y2);

          targetCtx.beginPath();
          targetCtx.moveTo(a[0], a[1]);
          targetCtx.lineTo(b[0], b[1]);
          targetCtx.stroke();

          const dx = x2 - x1,
            dy = y2 - y1;
          const len = Math.hypot(dx, dy);

          if (len > 0) {
            let nx, ny;
            if (boundaryOrientation >= 0) {
              nx = dy / len;
              ny = -dx / len;
            } else {
              nx = -dy / len;
              ny = dx / len;
            }

            // طول کل Segment
            if (withMeasurements) {
              const midx = (x1 + x2) / 2,
                midy = (y1 + y2) / 2;
              const off = 8;
              const lx = midx + nx * off,
                ly = midy + ny * off;
              const ls = worldToScreen(lx, ly);
              targetCtx.fillStyle = '#dbe7ff';
              targetCtx.shadowColor = 'rgba(0,0,0,.7)';
              targetCtx.shadowBlur = 6;
              targetCtx.font = '12px Inter, sans-serif';
              targetCtx.textAlign = 'center';
              targetCtx.textBaseline = 'middle';
              targetCtx.fillText(len.toFixed(2) + ' cm', ls[0], ls[1]);
              targetCtx.shadowBlur = 0;
            }

            // نقاط تقسیم Segment
            if (segmentSubdivEnabled && segStep > 0) {
              const count = Math.floor(len / segStep);
              for (let k = 1; k <= count; k++) {
                const d = k * segStep;
                if (d >= len) break;
                const px = x1 + (dx / len) * d,
                  py = y1 + (dy / len) * d;

                const dotOff = 3;
                const dotX = px + nx * dotOff,
                  dotY = py + ny * dotOff;
                const ds = worldToScreen(dotX, dotY);

                // نقطه
                targetCtx.beginPath();
                targetCtx.fillStyle = '#e5e7eb';
                targetCtx.arc(ds[0], ds[1], 2, 0, Math.PI * 2);
                targetCtx.fill();

                // عدد کنار نقطه (چند سانت)
                if (withMeasurements) {
                  const labOff = 10;
                  const lx = px + nx * labOff,
                    ly = py + ny * labOff;
                  const ls = worldToScreen(lx, ly);
                  targetCtx.fillStyle = '#e5e7eb';
                  targetCtx.font = '11px Inter, sans-serif';
                  targetCtx.textAlign = 'center';
                  targetCtx.textBaseline = 'middle';
                  targetCtx.fillText(d.toFixed(0) + ' cm', ls[0], ls[1]); 
                }
              }
            }
          }
        }

        // Grid
        drawGrid(targetCtx, clientW, clientH);

        // Shapes
        shapes.forEach(sh => {
          targetCtx.save();
          const sxsy = worldToScreen(sh.cx, sh.cy);
          targetCtx.translate(sxsy[0], sxsy[1]);
          targetCtx.rotate((-sh.angle || 0) * Math.PI / 180);
          const w = sh.w * view.scale,
            h = sh.h * view.scale;

          if (sh.fill && sh.fill !== 'transparent') {
            targetCtx.fillStyle = sh.fill;
            targetCtx.fillRect(-w / 2, -h / 2, w, h);
          }

          targetCtx.lineWidth = 2;
          targetCtx.strokeStyle = sh.stroke || '#ffffff';
          targetCtx.strokeRect(-w / 2, -h / 2, w, h);

          if (sh.selected) {
            targetCtx.strokeStyle = '#f59e0b';
            targetCtx.setLineDash([6, 6]);
            targetCtx.strokeRect(-w / 2 - 8, -h / 2 - 8, w + 16, h + 16);
            targetCtx.setLineDash([]);
          }

          targetCtx.fillStyle = '#ffffff';
          targetCtx.font = 'bold 14px Inter, sans-serif';
          targetCtx.textAlign = 'center';
          targetCtx.textBaseline = 'middle';
          if (sh.label) targetCtx.fillText(sh.label.toUpperCase(), 0, 0);

          if (withMeasurements && showShapeDimsInside) {
            targetCtx.font = '11px Inter, sans-serif';
            targetCtx.textAlign = 'center';
            targetCtx.textBaseline = 'top';
            const dimText = sh.w.toFixed(1) + ' x ' + sh.h.toFixed(1) + ' cm';
            targetCtx.fillText(dimText, 0, 6);
          }

          targetCtx.restore();
        });

        targetCtx.restore();
      }

      // Zoom with wheel
      canvas.addEventListener(
        'wheel',
        e => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left,
            my = e.clientY - rect.top;
          const scaleAmount = Math.exp(-e.deltaY * 0.0015);
          const before = screenToWorld(mx, my);
          view.scale *= scaleAmount;
          view.scale = Math.max(0.05, Math.min(10, view.scale));
          const after = screenToWorld(mx, my);
          view.tx += (after[0] - before[0]) * view.scale;
          view.ty += (after[1] - before[1]) * view.scale;
          updateZoomLabel();
          draw();
        },
        {
          passive: false
        }
      );

      // Mouse events (pan & drag shapes)
      canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left,
          y = e.clientY - rect.top;
        const hit = hitTestShape(x, y);
        if (hit) {
          draggingShape = hit;
          draggingShape.offset = screenToWorld(x, y);
          draggingShape.offset[0] -= hit.cx;
          draggingShape.offset[1] -= hit.cy;
          shapes.forEach(s => (s.selected = false));
          hit.selected = true;
          syncEditorWithSelected(true);
          draw();
          return;
        }
        dragging = true;
        lastPos = {
          x: e.clientX,
          y: e.clientY
        };
      });

      canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left,
          y = e.clientY - rect.top;

        const hitEdge = hitTestEdge(x, y);
        if (hitEdge && showMeasurements) {
          hoverInfo.style.display = 'block';
          hoverInfo.style.left = e.clientX + 12 + 'px';
          hoverInfo.style.top = e.clientY + 12 + 'px';
          hoverInfo.textContent = hitEdge.length.toFixed(2) + ' cm';
        } else {
          hoverInfo.style.display = 'none';
        }

        if (dragging && lastPos) {
          const dx = e.clientX - lastPos.x,
            dy = e.clientY - lastPos.y;
          view.tx += dx;
          view.ty += dy;
          lastPos = {
            x: e.clientX,
            y: e.clientY
          };
          draw();
        }

        if (draggingShape) {
          const wpos = screenToWorld(x, y);
          let nx = wpos[0] - draggingShape.offset[0];
          let ny = wpos[1] - draggingShape.offset[1];
          const old = {
            cx: draggingShape.cx,
            cy: draggingShape.cy
          };
          draggingShape.cx = nx;
          draggingShape.cy = ny;
          if (magnetive) {
            const snapped = snapAgainstOthers(draggingShape);
            draggingShape.cx = snapped.cx;
            draggingShape.cy = snapped.cy;
          }
          if (!shapeInsideBoundary(draggingShape)) {
            draggingShape.cx = old.cx;
            draggingShape.cy = old.cy;
          }
          syncEditorWithSelected(true);
          draw();
        }
      });

      canvas.addEventListener('mouseup', () => {
        dragging = false;
        lastPos = null;
        draggingShape = null;
      });
      canvas.addEventListener('mouseleave', () => {
        dragging = false;
        lastPos = null;
        draggingShape = null;
        hoverInfo.style.display = 'none';
      });

      // Hit tests
      function hitTestShape(sx, sy) {
        for (let i = shapes.length - 1; i >= 0; i--) {
          const sh = shapes[i];
          const pt = screenToWorld(sx, sy);
          const rx = pt[0] - sh.cx,
            ry = pt[1] - sh.cy;
          const a = (sh.angle || 0) * Math.PI / 180;
          const rxr = rx * Math.cos(a) + ry * Math.sin(a);
          const ryr = -rx * Math.sin(a) + ry * Math.cos(a);
          if (Math.abs(rxr) <= sh.w / 2 + 1 && Math.abs(ryr) <= sh.h / 2 + 1) return sh;
        }
        return null;
      }

      function hitTestEdge(sx, sy) {
        if (!segments || segments.length === 0) return null;
        for (let i = 0; i < segments.length; i++) {
          const s = segments[i];
          const A = worldToScreen(s.start_point.x, s.start_point.y);
          const B = worldToScreen(s.end_point.x, s.end_point.y);
          const d = pointToSegmentDistance(sx, sy, A[0], A[1], B[0], B[1]);
          if (d < 6) {
            const len = Math.hypot(
              s.end_point.x - s.start_point.x,
              s.end_point.y - s.start_point.y
            );
            return {
              index: i,
              length: len
            };
          }
        }
        return null;
      }

      function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1,
          B = py - y1,
          C = x2 - x1,
          D = y2 - y1;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        const dx = px - xx,
          dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Geometry helpers
      function pointInPolygon(point, vs) {
        const x = point[0],
          y = point[1];
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          const xi = vs[i][0],
            yi = vs[i][1],
            xj = vs[j][0],
            yj = vs[j][1];
          const intersect =
            (yi > y) !== (yj > y) &&
            x < ((xj - xi) * (y - yi)) / (yj - yi + 0.000000001) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function shapeInsideBoundary(sh) {
        if (boundary.length < 3) return false;
        const hw = sh.w / 2,
          hh = sh.h / 2,
          ang = (sh.angle * Math.PI) / 180;
        const corners = [
          [-hw, -hh],
          [hw, -hh],
          [hw, hh],
          [-hw, hh]
        ].map(c => {
          const rx = c[0],
            ry = c[1];
          const wx = sh.cx + (rx * Math.cos(ang) - ry * Math.sin(ang));
          const wy = sh.cy + (rx * Math.sin(ang) + ry * Math.cos(ang));
          return [wx, wy];
        });
        return corners.every(c => pointInPolygon(c, boundary));
      }

      function getCorners(sh) {
        const hw = sh.w / 2,
          hh = sh.h / 2,
          ang = (sh.angle * Math.PI) / 180;
        return [
          [-hw, -hh],
          [hw, -hh],
          [hw, hh],
          [-hw, hh]
        ].map(c => {
          const rx = c[0],
            ry = c[1];
          return [
            sh.cx + (rx * Math.cos(ang) - ry * Math.sin(ang)),
            sh.cy + (rx * Math.sin(ang) + ry * Math.cos(ang))
          ];
        });
      }

      function getAABB(sh) {
        const c = getCorners(sh);
        const xs = c.map(p => p[0]),
          ys = c.map(p => p[1]);
        return {
          left: Math.min(...xs),
          right: Math.max(...xs),
          top: Math.min(...ys),
          bottom: Math.max(...ys),
          cx: sh.cx,
          cy: sh.cy
        };
      }

      function snapAgainstOthers(target) {
        const threshold = MAGNET_THRESHOLD_CM;
        let best = {
          cx: target.cx,
          cy: target.cy,
          score: Infinity
        };
        const tb = getAABB(target);
        for (const other of shapes) {
          if (other === target) continue;
          const ob = getAABB(other);
          const candidates = [];
          // Left/right edges
          candidates.push({
            type: 'x',
            val: ob.left - (tb.right - tb.cx)
          });
          candidates.push({
            type: 'x',
            val: ob.right - (tb.left - tb.cx)
          });
          // Top/bottom edges
          candidates.push({
            type: 'y',
            val: ob.top - (tb.bottom - tb.cy)
          });
          candidates.push({
            type: 'y',
            val: ob.bottom - (tb.top - tb.cy)
          });
          // Center align
          candidates.push({
            type: 'x',
            val: ob.cx - tb.cx
          });
          candidates.push({
            type: 'y',
            val: ob.cy - tb.cy
          });

          for (const c of candidates) {
            let cx = target.cx,
              cy = target.cy;
            if (c.type === 'x') cx = c.val;
            else cy = c.val;

            const dx = Math.abs(cx - target.cx),
              dy = Math.abs(cy - target.cy);
            const dist = Math.hypot(dx, dy);
            if (dist <= threshold) {
              const tmp = { ...target };
              tmp.cx = cx;
              tmp.cy = cy;
              if (shapeInsideBoundary(tmp)) {
                if (dist < best.score) {
                  best = {
                    cx,
                    cy,
                    score: dist
                  };
                }
              }
            }
          }
        }
        return {
          cx: best.cx,
          cy: best.cy
        };
      }

      // Shape type toggle
      document.getElementById('shapeType').addEventListener('change', e => {
        const t = e.target.value;
        if (t === 'square') {
          document.getElementById('side').classList.remove('hidden');
          document.getElementById('width').classList.add('hidden');
          document.getElementById('height').classList.add('hidden');
        } else {
          document.getElementById('side').classList.add('hidden');
          document.getElementById('width').classList.remove('hidden');
          document.getElementById('height').classList.remove('hidden');
        }
      });

      const strokeColor = document.getElementById('strokeColor');
      const fillColor = document.getElementById('fillColor');
      const noFill = document.getElementById('noFill');
      const labelText = document.getElementById('labelText');

      function tryPlaceInside(sh) {
        if (boundary.length === 0) return false;
        const xs = boundary.map(p => p[0]),
          ys = boundary.map(p => p[1]);
        const xmin = Math.min(...xs),
          xmax = Math.max(...xs),
          ymin = Math.min(...ys),
          ymax = Math.max(...ys);
        const cx = (xmin + xmax) / 2,
          cy = (ymin + ymax) / 2;
        const step = Math.max(2, Math.min(sh.w, sh.h) / 4);
        const candidates = [];
        for (let r = 0; r < 8; r++) {
          const rad = r * step;
          for (let ang = 0; ang < 360; ang += 15) {
            const px = cx + rad * Math.cos((ang * Math.PI) / 180),
              py = cy + rad * Math.sin((ang * Math.PI) / 180);
            candidates.push([px, py]);
          }
        }
        candidates.unshift([cx, cy]);
        for (const c of candidates) {
          sh.cx = c[0];
          sh.cy = c[1];
          if (shapeInsideBoundary(sh)) return true;
        }
        return false;
      }

      // Add Shape
      document.getElementById('addShape').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const t = document.getElementById('shapeType').value;
        const angle = Number(document.getElementById('angle').value || 0);
        let w = 0,
          h = 0;
        if (t === 'square') {
          w = Number(document.getElementById('side').value || 0);
          h = w;
        } else {
          w = Number(document.getElementById('width').value || 0);
          h = Number(document.getElementById('height').value || 0);
        }
        if (w <= 0 || h <= 0) {
          toast('Invalid dimensions', 'err');
          return;
        }
        if (boundary.length === 0) {
          toast('Load boundary data first', 'err');
          return;
        }
        const fillSel = noFill.checked ? 'transparent' : fillColor.value;
        const strokeSel = strokeColor.value || '#ffffff';
        const lbl = (labelText.value || '').toUpperCase().slice(0, 3);
        const sh = {
          id: Date.now() + Math.random(),
          type: t,
          w: Number(w),
          h: Number(h),
          cx: 0,
          cy: 0,
          angle,
          fill: fillSel,
          stroke: strokeSel,
          label: lbl,
          selected: false
        };
        if (!tryPlaceInside(sh)) {
          toast('No valid position inside boundary for this size', 'err');
          return;
        }
        if (magnetive) {
          const snapped = snapAgainstOthers(sh);
          sh.cx = snapped.cx;
          sh.cy = snapped.cy;
        }
        shapes.push(sh);
        shapes.forEach(s => (s.selected = false));
        sh.selected = true;
        syncEditorWithSelected(true);
        draw();
      });

      // Clear shapes
      document.getElementById('clearShapes').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        shapes = [];
        syncEditorWithSelected(false);
        draw();
      });

      // Delete shape
      document.getElementById('deleteShape').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const idx = shapes.findIndex(s => s.selected);
        if (idx >= 0) {
          shapes.splice(idx, 1);
          syncEditorWithSelected(false);
          draw();
        }
      });

      // Rotate shape
      document.getElementById('rotateShape').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const s = shapes.find(s => s.selected);
        if (!s) return;
        s.angle = (s.angle + 5) % 360;
        if (!shapeInsideBoundary(s)) {
          s.angle = (s.angle + 355) % 360;
        }
        syncEditorWithSelected(true);
        draw();
      });

      // Apply edits
      document.getElementById('applyEdit').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const s = shapes.find(s => s.selected);
        if (!s) return;
        let w = s.w,
          h = s.h;
        const ang = Number(document.getElementById('angle').value || 0);
        if (s.type === 'square') {
          const v = Number(document.getElementById('side').value || s.w);
          w = v;
          h = v;
        } else {
          w = Number(document.getElementById('width').value || s.w);
          h = Number(document.getElementById('height').value || s.h);
        }
        const newStroke = strokeColor.value || '#ffffff';
        const newFill = noFill.checked ? 'transparent' : fillColor.value;
        const newLabel = (labelText.value || '').toUpperCase().slice(0, 3);
        const prev = {
          w: s.w,
          h: s.h,
          angle: s.angle,
          stroke: s.stroke,
          fill: s.fill,
          label: s.label,
          cx: s.cx,
          cy: s.cy
        };
        s.w = w;
        s.h = h;
        s.angle = ang;
        s.stroke = newStroke;
        s.fill = newFill;
        s.label = newLabel;
        if (magnetive) {
          const snapped = snapAgainstOthers(s);
          s.cx = snapped.cx;
          s.cy = snapped.cy;
        }
        if (!shapeInsideBoundary(s)) {
          if (!tryPlaceInside(s)) {
            // roll back
            s.w = prev.w;
            s.h = prev.h;
            s.angle = prev.angle;
            s.stroke = prev.stroke;
            s.fill = prev.fill;
            s.label = prev.label;
            s.cx = prev.cx;
            s.cy = prev.cy;
            toast('Edits must remain inside boundary', 'err');
          }
        }
        syncEditorWithSelected(true);
        draw();
      });

      function syncEditorWithSelected(hasSel) {
        const info = document.getElementById('selectedInfo');
        const typeSel = document.getElementById('shapeType');
        if (!hasSel) {
          info.textContent = 'None';
          typeSel.disabled = false;
          typeSel.value = 'square';
          document.getElementById('side').classList.remove('hidden');
          document.getElementById('width').classList.add('hidden');
          document.getElementById('height').classList.add('hidden');
          document.getElementById('side').value = '';
          document.getElementById('width').value = '';
          document.getElementById('height').value = '';
          document.getElementById('angle').value = '0';
          strokeColor.value = '#ffffff';
          fillColor.value = '#000000';
          noFill.checked = false;
          labelText.value = '';
          return;
        }
        const sel = shapes.find(s => s.selected);
        if (!sel) {
          syncEditorWithSelected(false);
          return;
        }
        info.innerHTML = `Type: ${sel.type} • W:${sel.w.toFixed(
          2
        )} cm H:${sel.h.toFixed(2)} cm • Angle:${sel.angle.toFixed(
          1
        )}° • Stroke ${sel.stroke} • Fill ${
          sel.fill === 'transparent' ? 'none' : sel.fill
        } • Label ${sel.label || '-'}`;
        typeSel.value = sel.type;
        typeSel.disabled = true;

        if (sel.type === 'square') {
          document.getElementById('side').classList.remove('hidden');
          document.getElementById('width').classList.add('hidden');
          document.getElementById('height').classList.add('hidden');
          document.getElementById('side').value = sel.w;
        } else {
          document.getElementById('side').classList.add('hidden');
          document.getElementById('width').classList.remove('hidden');
          document.getElementById('height').classList.remove('hidden');
          document.getElementById('width').value = sel.w;
          document.getElementById('height').value = sel.h;
        }
        document.getElementById('angle').value = sel.angle;
        strokeColor.value = sel.stroke || '#ffffff';
        if (sel.fill === 'transparent') {
          noFill.checked = true;
        } else {
          noFill.checked = false;
          fillColor.value = sel.fill;
        }
        labelText.value = sel.label || '';
      }

      // Toggles & controls
      document.getElementById('toggleMeasurements').addEventListener('change', e => {
        showMeasurements = e.target.checked;
        hoverInfo.style.display = 'none';
        draw();
      });

      document.getElementById('toggleMagnet').addEventListener('change', e => {
        magnetive = e.target.checked;
      });

      document.getElementById('toggleSegmentSubdiv').addEventListener('change', e => {
        segmentSubdivEnabled = e.target.checked;
        draw();
      });

      document.getElementById('toggleShapeDimsInside').addEventListener('change', e => {
        showShapeDimsInside = e.target.checked;
        draw();
      });

      document.getElementById('toggleGrid').addEventListener('change', e => {
        if (e.target.checked) {
          let v = parseFloat(document.getElementById('gridSpacing').value) || 0;
          if (v <= 0) {
            v = 5;
            document.getElementById('gridSpacing').value = '5';
          }
          gridSpacingCm = v;
          gridEnabled = true;
        } else {
          gridEnabled = false;
        }
        draw();
      });

      document.getElementById('gridSpacing').addEventListener('change', e => {
        let v = parseFloat(e.target.value) || 0;
        if (v <= 0) {
          toast('Grid spacing must be > 0', 'err');
          e.target.value = gridSpacingCm.toString();
          return;
        }
        gridSpacingCm = v;
        if (document.getElementById('toggleGrid').checked) gridEnabled = true;
        draw();
      });

      document.getElementById('gridColor').addEventListener('change', e => {
        gridColor = e.target.value || '#1f2937';
        draw();
      });

      // NEW: segmentStep input handler
      const segmentStepInput = document.getElementById('segmentStep');
      segmentStepInput.addEventListener('change', e => {
        let v = parseFloat(e.target.value) || 0;
        if (v <= 0) {
          toast('Segment size must be > 0', 'err');
          e.target.value = segmentStepCm.toString();
          return;
        }
        segmentStepCm = v;
        if (segmentSubdivEnabled) draw();
      });

      // Zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => {
        view.scale *= 1.2;
        updateZoomLabel();
        draw();
      });
      document.getElementById('zoomOut').addEventListener('click', () => {
        view.scale /= 1.2;
        updateZoomLabel();
        draw();
      });
      document.getElementById('fitBtn').addEventListener('click', () => {
        fitToView();
        draw();
      });

      function updateZoomLabel() {
        document.getElementById('zoomLevel').textContent =
          Math.round(view.scale * 100) + '%';
      }

      // Export PNG
      function exportPNG() {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const out = document.createElement('canvas');
        const w = Math.max(1200, canvas.clientWidth * 2),
          h = Math.max(800, canvas.clientHeight * 2);
        out.width = w;
        out.height = h;
        const octx = out.getContext('2d');
        octx.fillStyle = '#060f1f';
        octx.fillRect(0, 0, w, h);
        const scale = w / canvas.clientWidth;
        octx.save();
        octx.scale(scale, scale);
        renderToContext(octx, canvas.clientWidth, canvas.clientHeight, showMeasurements);
        octx.restore();
        out.toBlob(blob => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'export.png';
          a.click();
          URL.revokeObjectURL(a.href);
        });
      }
      document.getElementById('exportPng').addEventListener('click', exportPNG);

      function clearCanvas() {
        boundary = [];
        segments = [];
        shapes = [];
        boundaryArea = 0;
        boundaryOrientation = 1;
        draw();
      }

      // File load
      const loadBtn = document.getElementById('loadFileBtn');
      const fileInput = document.getElementById('fileInput');
      const fileNameEl = document.getElementById('fileName');

      loadBtn.addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        fileInput.value = '';
        fileInput.click();
      });

      fileInput.addEventListener('change', async e => {
        const f = e.target.files[0];
        if (!f) return;
        fileNameEl.textContent = 'Loaded: ' + f.name;
        const ext = f.name.split('.').pop().toLowerCase();
        try {
          if (ext === 'json') {
            const t = await f.text();
            const j = JSON.parse(t);
            ingestJSON(j);
            toast('JSON loaded');
          } else if (ext === 'xlsx' || ext === 'xls') {
            const data = await f.arrayBuffer();
            const wb = XLSX.read(data, {
              type: 'array'
            });
            ingestWorkbook(wb);
            toast('Excel loaded');
          } else {
            toast('Unsupported file', 'err');
          }
        } catch (err) {
          toast('Failed to load file', 'err');
        }
      });

      function ingestJSON(j) {
        boundary = (j.points || []).map(p => [Number(p[0]), Number(p[1])]);
        segments = (j.segments || []).map((s, idx) => ({
          index: idx,
          start_point: {
            x: Number(s.start_point.x),
            y: Number(s.start_point.y)
          },
          end_point: {
            x: Number(s.end_point.x),
            y: Number(s.end_point.y)
          }
        }));
        shapes = [];
        updateBoundaryOrientation();
        fitToView();
        resizeCanvas();
        draw();
      }

      function ingestWorkbook(wb) {
        let pts = [],
          segs = [];
        const sheetNames = wb.SheetNames.map(n => n.toLowerCase());
        const ptsName = sheetNames.find(n => /points?|vertices?/.test(n));
        const segName = sheetNames.find(n => /segments?|edges?/.test(n));

        if (ptsName) {
          const arr = XLSX.utils.sheet_to_json(
            wb.Sheets[wb.SheetNames[sheetNames.indexOf(ptsName)]],
            {
              header: 1
            }
          );
          arr.forEach(r => {
            if (r.length >= 2 && isFinite(r[0]) && isFinite(r[1]))
              pts.push([Number(r[0]), Number(r[1])]);
          });
        }

        if (segName) {
          const arr = XLSX.utils.sheet_to_json(
            wb.Sheets[wb.SheetNames[sheetNames.indexOf(segName)]],
            {
              header: 1
            }
          );
          arr.forEach(r => {
            if (r.length >= 4 && [0, 1, 2, 3].every(i => isFinite(r[i])))
              segs.push({
                start_point: {
                  x: Number(r[0]),
                  y: Number(r[1])
                },
                end_point: {
                  x: Number(r[2]),
                  y: Number(r[3])
                }
              });
          });
        }

        if (!pts.length && wb.Sheets[wb.SheetNames[0]]) {
          const arr = XLSX.utils.sheet_to_json(
            wb.Sheets[wb.SheetNames[0]],
            {
              header: 1
            }
          );
          arr.forEach(r => {
            if (r.length >= 2 && isFinite(r[0]) && isFinite(r[1]))
              pts.push([Number(r[0]), Number(r[1])]);
          });
        }

        boundary = pts;
        segments = segs.map((s, idx) => ({
          index: idx,
          ...s
        }));
        shapes = [];
        updateBoundaryOrientation();
        fitToView();
        resizeCanvas();
        draw();
      }

      // Shape Import / Export
      document.getElementById('importShapeBtn').addEventListener('click', async () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const f = await pickJSON();
        if (!f) return;
        try {
          const t = await f.text();
          const j = JSON.parse(t);
          if (j.w && j.h && j.cx !== undefined) {
            const sh = {
              id: Date.now(),
              type: j.w === j.h ? 'square' : 'rect',
              w: Number(j.w),
              h: Number(j.h),
              cx: Number(j.cx),
              cy: Number(j.cy),
              angle: Number(j.angle || 0),
              fill: j.fill || 'transparent',
              stroke: j.stroke || '#ffffff',
              label: (j.label || '').toUpperCase().slice(0, 3),
              selected: false
            };
            if (!tryPlaceInside(sh)) {
              toast('Imported shape cannot fit inside boundary', 'err');
              return;
            }
            if (magnetive) {
              const snapped = snapAgainstOthers(sh);
              sh.cx = snapped.cx;
              sh.cy = snapped.cy;
            }
            shapes.push(sh);
            draw();
            toast('Shape imported');
          } else {
            toast('Invalid shape file', 'err');
          }
        } catch (e) {
          toast('Invalid file', 'err');
        }
      });

      document.getElementById('exportShapeBtn').addEventListener('click', () => {
        if (!signedIn) {
          toast('Please sign in first', 'err');
          return;
        }
        const sel = shapes.find(s => s.selected);
        if (!sel) {
          toast('Select a shape first', 'err');
          return;
        }
        const data = {
          w: sel.w,
          h: sel.h,
          cx: sel.cx,
          cy: sel.cy,
          angle: sel.angle,
          stroke: sel.stroke,
          fill: sel.fill,
          label: sel.label
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: 'application/json'
        });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'shape.json';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      function pickJSON() {
        return new Promise(res => {
          const inp = document.createElement('input');
          inp.type = 'file';
          inp.accept = '.json,application/json';
          inp.onchange = e => {
            res(e.target.files[0]);
          };
          inp.click();
        });
      }

      resizeCanvas();
    </script>
  </body>
</html>
